# Лабораторная работа №3 Карданова Екатерина

* **Цель:** научиться реализовывать структуры данных и сортировки
* **Библиотеки:** *Unittest*
* **Чему я научилась:**
    - реализовывать функции факториала и Фибоначчи
    - использовать различные сортировки
    - работать со структурами данных


## Структура проекта

 <pre>
    .
    ├── lab<# лабораторной работы>             # Кодовая база вашей лабораторной работы
    │   ├── src/                               # Исходный код
    |   │   ├── fact_fibo/                     # Функции факториала и Фибоначчи
    |   │   ├── sorts/                         # Функции сортировки
    |   │   ├── class_stack                    # Реализация стека на list
    │   ├── tests/                             # Unit тесты
    │   ├── uv.lock                            # зависимости вашего проекта
    │   ├── report.pdf                         # Отчет
    │   ├── .gitignore                         # git ignore файл
    │   ├──.pre-commit-config.yaml             # Средства автоматизации проверки кодстайла
    │   ├── README.md                          # Описание вашего проекта, с описанием файлов и с титульником о том,
                                               # что и какая задача
</pre>


## Инструкция к использованию

### Установить репозиторий
```pip install -e git+https://github.com/TinaGrav/lab-3-python``` \
```cd src/lab-3-python```

### Запустить
```python -m src.main```
После запуска программы пользователь увидит приветсвенное сообщение и инструкцию по работе с программой. 

# Допущения
- Пользователь вводит название команды при начале работы, а также данные с которыми будет работать функция
- Фиббоначи считается для чисел больших нуля
- Факториал считается для чисел больших или равным нулю
- Чтобы пользователь не ожидал ответа слишком долго, а также не было превышений по рекурсии были введены следующие ограничения:
- - Ограничение по вводу факториала - 50000, рекурсивного факториала - 995
- - Ограничение по вводу Фибоначчи - 50000, рекурсивного Фибоначчи - 500
- На вход bubble_sort может даваться массив из отрицательных или нецелых чисел
- На вход quick_sort может даваться массив из отрицательных или нецелых чисел
- На вход counting_sort может даваться массив только из натуральных чисел или нуля
- На вход radix_sort может даваться массив только из натуральных чисел или нуля
- На вход bucket_sort может даваться массив только из неотрицательных чиселБ при этом они могут быть нецелыми. При реализации bucket_sort используется bubble_sort
- На вход heap_sort может даваться массив из отрицательных или нецелых чисел


# Алгоритм работы
При запуске программы пользователь вводит, какой функцией он хочет воспользоваться, аргументы для использования функции - число или массив. Программа обращается к функции, которая необходима пользователю, обрабатывает входное число и выводит ответ. В случае неправильно введенных чисел для конкретной функции, выводится ошибка. Для одного запуска предусмотрена только одна операция - если пользователь хочет воспользоваться несколькими функциями, ему необходимо запустить программу ещё раз.

Во время работы программа может обращаться к следующим функциям:
## factorial_recursive
  Подсчет факториала при помощью рекурсии - число n умножается на факториал n-1
## factorial
  Факториал без рекурсии - перемножаются все числа от 1 до n 
## fibo_recursive
  Подсчет числа Фибоначчи с заданным номером при помощи рекурсии. Суммируется число Фибоначчи n-1 и число Фибоначчи n-2
## fibo
  Подсчет числа Фибоначчи без рекурсии. Создаются две переменные, изначально равные 0 и 1. Чтобы найти n элемент, n раз в первую переменную присываивается значение второй, а вторая становится суммой обоих элементов. 
  
## bubble_sort
 До тех пор, пока список не отсортируется функция обрабатывает каждый элемент массива, и если левый элемент больше правоого, они переставляются местами.
 
## quick_sort
 Берется начальный элемент из середины массива. Создается три массива: левый, средний и правыйБ в каждый из них добавляются соттветсвенно элементы меньшие стартового элемента, равные ему и большие его. Функция быстрой сортировки применяется к левому и правому массиву, чтобы отсортировать элементы внутри каждого такого массива. 
 
## counting_sort
 В начале создается массив для подсчета, состоящий из количества элементов, равного максимальному числу из входного массива плюс 1. Обрабатывается каждый элемент массива n, прибавляется единица в n-й элемент массива подсчета. Создается также массив для вывода ответа, в который размещает числа из входного массива в правильном порядке, основываясь на результатх массива подсчета
 
## radix_sort
 В начале вычисляется количество разрядов макимального числа из входново массива. Создается 10 подмассивов для цифр в разряде, функция перебирает все элементы массива и распределяет их по подмассивам, согласно цифре разряда элемента, затем возвращаем числа в исходный массив с учетом перестановки. Повторяем так для каждого разряда.

## bucket_sort
Функция разбивает входной массив на заданное количество частей (на 4 части, если пользователь не ввел число корзин в начале) и использует bubble_sort для сортировки чисел внутри каждой корзины. Диапазон числел, входящих в корзину, зависит от максимального числа входного массива.

## heap_sort
Функция строит кучу из всех элементов и ставит во главу кучи максимальный элемент массива. Максимальный элемент убирается из кучи в конец массива, на его место ставится следующий элменет массива. Преобразовываем кучу так, чтобы каждый родительский элемент кучи был больше элементов-потомков. Повторяем операцию до полной сортировки так, чтобы при каждом преобразовании кучи в вершине оказывался самый большой элемент. 

## class Stack
Реализация стека на list. Для него реализованы следующие команды: 
- push - добавляет элемент, который вводит пользователь, в конец массива
- pop - убирает последний элемент массива
- peek - показывает последний элемент массива
- is_empty - возвращает True, если массив пуст, иначе False
- __len__ - показывает длину массива
- min - показывает минимальный элемент массива
Массив в который добавляются элементы создаётся автоматически как только пользователь обращается к Stack
